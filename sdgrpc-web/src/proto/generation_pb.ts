// @generated by protoc-gen-es v0.2.1 with parameter "target=ts"
// @generated from file generation.proto (package gooseai, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";

/**
 * @generated from enum gooseai.FinishReason
 */
export enum FinishReason {
  /**
   * @generated from enum value: NULL = 0;
   */
  NULL = 0,

  /**
   * @generated from enum value: LENGTH = 1;
   */
  LENGTH = 1,

  /**
   * @generated from enum value: STOP = 2;
   */
  STOP = 2,

  /**
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,

  /**
   * @generated from enum value: FILTER = 4;
   */
  FILTER = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(FinishReason)
proto3.util.setEnumType(FinishReason, "gooseai.FinishReason", [
  { no: 0, name: "NULL" },
  { no: 1, name: "LENGTH" },
  { no: 2, name: "STOP" },
  { no: 3, name: "ERROR" },
  { no: 4, name: "FILTER" },
]);

/**
 * @generated from enum gooseai.ArtifactType
 */
export enum ArtifactType {
  /**
   * @generated from enum value: ARTIFACT_NONE = 0;
   */
  ARTIFACT_NONE = 0,

  /**
   * @generated from enum value: ARTIFACT_IMAGE = 1;
   */
  ARTIFACT_IMAGE = 1,

  /**
   * @generated from enum value: ARTIFACT_VIDEO = 2;
   */
  ARTIFACT_VIDEO = 2,

  /**
   * @generated from enum value: ARTIFACT_TEXT = 3;
   */
  ARTIFACT_TEXT = 3,

  /**
   * @generated from enum value: ARTIFACT_TOKENS = 4;
   */
  ARTIFACT_TOKENS = 4,

  /**
   * @generated from enum value: ARTIFACT_EMBEDDING = 5;
   */
  ARTIFACT_EMBEDDING = 5,

  /**
   * @generated from enum value: ARTIFACT_CLASSIFICATIONS = 6;
   */
  ARTIFACT_CLASSIFICATIONS = 6,

  /**
   * @generated from enum value: ARTIFACT_MASK = 7;
   */
  ARTIFACT_MASK = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(ArtifactType)
proto3.util.setEnumType(ArtifactType, "gooseai.ArtifactType", [
  { no: 0, name: "ARTIFACT_NONE" },
  { no: 1, name: "ARTIFACT_IMAGE" },
  { no: 2, name: "ARTIFACT_VIDEO" },
  { no: 3, name: "ARTIFACT_TEXT" },
  { no: 4, name: "ARTIFACT_TOKENS" },
  { no: 5, name: "ARTIFACT_EMBEDDING" },
  { no: 6, name: "ARTIFACT_CLASSIFICATIONS" },
  { no: 7, name: "ARTIFACT_MASK" },
]);

/**
 * @generated from enum gooseai.GaussianDirection
 */
export enum GaussianDirection {
  /**
   * @generated from enum value: DIRECTION_NONE = 0;
   */
  DIRECTION_NONE = 0,

  /**
   * @generated from enum value: DIRECTION_UP = 1;
   */
  DIRECTION_UP = 1,

  /**
   * @generated from enum value: DIRECTION_DOWN = 2;
   */
  DIRECTION_DOWN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GaussianDirection)
proto3.util.setEnumType(GaussianDirection, "gooseai.GaussianDirection", [
  { no: 0, name: "DIRECTION_NONE" },
  { no: 1, name: "DIRECTION_UP" },
  { no: 2, name: "DIRECTION_DOWN" },
]);

/**
 * @generated from enum gooseai.ChannelSource
 */
export enum ChannelSource {
  /**
   * @generated from enum value: CHANNEL_R = 0;
   */
  CHANNEL_R = 0,

  /**
   * @generated from enum value: CHANNEL_G = 1;
   */
  CHANNEL_G = 1,

  /**
   * @generated from enum value: CHANNEL_B = 2;
   */
  CHANNEL_B = 2,

  /**
   * @generated from enum value: CHANNEL_A = 3;
   */
  CHANNEL_A = 3,

  /**
   * @generated from enum value: CHANNEL_ZERO = 4;
   */
  CHANNEL_ZERO = 4,

  /**
   * @generated from enum value: CHANNEL_ONE = 5;
   */
  CHANNEL_ONE = 5,

  /**
   * @generated from enum value: CHANNEL_DISCARD = 6;
   */
  CHANNEL_DISCARD = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ChannelSource)
proto3.util.setEnumType(ChannelSource, "gooseai.ChannelSource", [
  { no: 0, name: "CHANNEL_R" },
  { no: 1, name: "CHANNEL_G" },
  { no: 2, name: "CHANNEL_B" },
  { no: 3, name: "CHANNEL_A" },
  { no: 4, name: "CHANNEL_ZERO" },
  { no: 5, name: "CHANNEL_ONE" },
  { no: 6, name: "CHANNEL_DISCARD" },
]);

/**
 * @generated from enum gooseai.RescaleMode
 */
export enum RescaleMode {
  /**
   * @generated from enum value: RESCALE_STRICT = 0;
   */
  RESCALE_STRICT = 0,

  /**
   * @generated from enum value: RESCALE_CROP = 2;
   */
  RESCALE_CROP = 2,

  /**
   * @generated from enum value: RESCALE_FIT = 3;
   */
  RESCALE_FIT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RescaleMode)
proto3.util.setEnumType(RescaleMode, "gooseai.RescaleMode", [
  { no: 0, name: "RESCALE_STRICT" },
  { no: 2, name: "RESCALE_CROP" },
  { no: 3, name: "RESCALE_FIT" },
]);

/**
 * DiffusionSampler identifies which sampler to use for Diffusion, and represents
 * the internal set of supported samplers.
 *
 * @generated from enum gooseai.DiffusionSampler
 */
export enum DiffusionSampler {
  /**
   * @generated from enum value: SAMPLER_DDIM = 0;
   */
  SAMPLER_DDIM = 0,

  /**
   * @generated from enum value: SAMPLER_DDPM = 1;
   */
  SAMPLER_DDPM = 1,

  /**
   * @generated from enum value: SAMPLER_K_EULER = 2;
   */
  SAMPLER_K_EULER = 2,

  /**
   * @generated from enum value: SAMPLER_K_EULER_ANCESTRAL = 3;
   */
  SAMPLER_K_EULER_ANCESTRAL = 3,

  /**
   * @generated from enum value: SAMPLER_K_HEUN = 4;
   */
  SAMPLER_K_HEUN = 4,

  /**
   * @generated from enum value: SAMPLER_K_DPM_2 = 5;
   */
  SAMPLER_K_DPM_2 = 5,

  /**
   * @generated from enum value: SAMPLER_K_DPM_2_ANCESTRAL = 6;
   */
  SAMPLER_K_DPM_2_ANCESTRAL = 6,

  /**
   * @generated from enum value: SAMPLER_K_LMS = 7;
   */
  SAMPLER_K_LMS = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(DiffusionSampler)
proto3.util.setEnumType(DiffusionSampler, "gooseai.DiffusionSampler", [
  { no: 0, name: "SAMPLER_DDIM" },
  { no: 1, name: "SAMPLER_DDPM" },
  { no: 2, name: "SAMPLER_K_EULER" },
  { no: 3, name: "SAMPLER_K_EULER_ANCESTRAL" },
  { no: 4, name: "SAMPLER_K_HEUN" },
  { no: 5, name: "SAMPLER_K_DPM_2" },
  { no: 6, name: "SAMPLER_K_DPM_2_ANCESTRAL" },
  { no: 7, name: "SAMPLER_K_LMS" },
]);

/**
 * Future, unimplemented.
 *
 * @generated from enum gooseai.Upscaler
 */
export enum Upscaler {
  /**
   * @generated from enum value: UPSCALER_RGB = 0;
   */
  RGB = 0,

  /**
   * @generated from enum value: UPSCALER_GFPGAN = 1;
   */
  GFPGAN = 1,

  /**
   * @generated from enum value: UPSCALER_ESRGAN = 2;
   */
  ESRGAN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Upscaler)
proto3.util.setEnumType(Upscaler, "gooseai.Upscaler", [
  { no: 0, name: "UPSCALER_RGB" },
  { no: 1, name: "UPSCALER_GFPGAN" },
  { no: 2, name: "UPSCALER_ESRGAN" },
]);

/**
 * Presets for CLIP guidance.
 *
 * @generated from enum gooseai.GuidancePreset
 */
export enum GuidancePreset {
  /**
   * @generated from enum value: GUIDANCE_PRESET_NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: GUIDANCE_PRESET_FAST = 1;
   */
  FAST = 1,

  /**
   * @generated from enum value: GUIDANCE_PRESET_EFFICIENT = 2;
   */
  EFFICIENT = 2,

  /**
   * @generated from enum value: GUIDANCE_PRESET_BALANCED = 3;
   */
  BALANCED = 3,

  /**
   * @generated from enum value: GUIDANCE_PRESET_QUALITY = 4;
   */
  QUALITY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(GuidancePreset)
proto3.util.setEnumType(GuidancePreset, "gooseai.GuidancePreset", [
  { no: 0, name: "GUIDANCE_PRESET_NONE" },
  { no: 1, name: "GUIDANCE_PRESET_FAST" },
  { no: 2, name: "GUIDANCE_PRESET_EFFICIENT" },
  { no: 3, name: "GUIDANCE_PRESET_BALANCED" },
  { no: 4, name: "GUIDANCE_PRESET_QUALITY" },
]);

/**
 * @generated from enum gooseai.ModelArchitecture
 */
export enum ModelArchitecture {
  /**
   * @generated from enum value: MODEL_ARCHITECTURE_NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: MODEL_ARCHITECTURE_CLIP_VIT = 1;
   */
  CLIP_VIT = 1,

  /**
   * @generated from enum value: MODEL_ARCHITECTURE_CLIP_RESNET = 2;
   */
  CLIP_RESNET = 2,

  /**
   * @generated from enum value: MODEL_ARCHITECTURE_LDM = 3;
   */
  LDM = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelArchitecture)
proto3.util.setEnumType(ModelArchitecture, "gooseai.ModelArchitecture", [
  { no: 0, name: "MODEL_ARCHITECTURE_NONE" },
  { no: 1, name: "MODEL_ARCHITECTURE_CLIP_VIT" },
  { no: 2, name: "MODEL_ARCHITECTURE_CLIP_RESNET" },
  { no: 3, name: "MODEL_ARCHITECTURE_LDM" },
]);

/**
 * @generated from enum gooseai.Action
 */
export enum Action {
  /**
   * @generated from enum value: ACTION_PASSTHROUGH = 0;
   */
  PASSTHROUGH = 0,

  /**
   * @generated from enum value: ACTION_REGENERATE_DUPLICATE = 1;
   */
  REGENERATE_DUPLICATE = 1,

  /**
   * @generated from enum value: ACTION_REGENERATE = 2;
   */
  REGENERATE = 2,

  /**
   * @generated from enum value: ACTION_OBFUSCATE_DUPLICATE = 3;
   */
  OBFUSCATE_DUPLICATE = 3,

  /**
   * @generated from enum value: ACTION_OBFUSCATE = 4;
   */
  OBFUSCATE = 4,

  /**
   * @generated from enum value: ACTION_DISCARD = 5;
   */
  DISCARD = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Action)
proto3.util.setEnumType(Action, "gooseai.Action", [
  { no: 0, name: "ACTION_PASSTHROUGH" },
  { no: 1, name: "ACTION_REGENERATE_DUPLICATE" },
  { no: 2, name: "ACTION_REGENERATE" },
  { no: 3, name: "ACTION_OBFUSCATE_DUPLICATE" },
  { no: 4, name: "ACTION_OBFUSCATE" },
  { no: 5, name: "ACTION_DISCARD" },
]);

/**
 * @generated from enum gooseai.ClassifierMode
 */
export enum ClassifierMode {
  /**
   * @generated from enum value: CLSFR_MODE_ZEROSHOT = 0;
   */
  CLSFR_MODE_ZEROSHOT = 0,

  /**
   * CLSFR_MODE_ODDSRATIO = 2;
   *
   * @generated from enum value: CLSFR_MODE_MULTICLASS = 1;
   */
  CLSFR_MODE_MULTICLASS = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ClassifierMode)
proto3.util.setEnumType(ClassifierMode, "gooseai.ClassifierMode", [
  { no: 0, name: "CLSFR_MODE_ZEROSHOT" },
  { no: 1, name: "CLSFR_MODE_MULTICLASS" },
]);

/**
 * @generated from enum gooseai.AssetAction
 */
export enum AssetAction {
  /**
   * @generated from enum value: ASSET_PUT = 0;
   */
  ASSET_PUT = 0,

  /**
   * @generated from enum value: ASSET_GET = 1;
   */
  ASSET_GET = 1,

  /**
   * @generated from enum value: ASSET_DELETE = 2;
   */
  ASSET_DELETE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AssetAction)
proto3.util.setEnumType(AssetAction, "gooseai.AssetAction", [
  { no: 0, name: "ASSET_PUT" },
  { no: 1, name: "ASSET_GET" },
  { no: 2, name: "ASSET_DELETE" },
]);

/**
 * @generated from enum gooseai.StageAction
 */
export enum StageAction {
  /**
   * @generated from enum value: STAGE_ACTION_PASS = 0;
   */
  PASS = 0,

  /**
   * @generated from enum value: STAGE_ACTION_DISCARD = 1;
   */
  DISCARD = 1,

  /**
   * @generated from enum value: STAGE_ACTION_RETURN = 2;
   */
  RETURN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StageAction)
proto3.util.setEnumType(StageAction, "gooseai.StageAction", [
  { no: 0, name: "STAGE_ACTION_PASS" },
  { no: 1, name: "STAGE_ACTION_DISCARD" },
  { no: 2, name: "STAGE_ACTION_RETURN" },
]);

/**
 * Generally, a GPT BPE 16-bit token, paired with an optional string representation.
 *
 * @generated from message gooseai.Token
 */
export class Token extends Message<Token> {
  /**
   * @generated from field: optional string text = 1;
   */
  text?: string;

  /**
   * @generated from field: uint32 id = 2;
   */
  id = 0;

  constructor(data?: PartialMessage<Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Token {
    return new Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJsonString(jsonString, options);
  }

  static equals(a: Token | PlainMessage<Token> | undefined, b: Token | PlainMessage<Token> | undefined): boolean {
    return proto3.util.equals(Token, a, b);
  }
}

/**
 * Sequence of tokens, paired with the id of the tokenizer used to generate them.
 *
 * @generated from message gooseai.Tokens
 */
export class Tokens extends Message<Tokens> {
  /**
   * @generated from field: repeated gooseai.Token tokens = 1;
   */
  tokens: Token[] = [];

  /**
   * @generated from field: optional string tokenizer_id = 2;
   */
  tokenizerId?: string;

  constructor(data?: PartialMessage<Tokens>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Tokens";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tokens", kind: "message", T: Token, repeated: true },
    { no: 2, name: "tokenizer_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tokens {
    return new Tokens().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tokens {
    return new Tokens().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tokens {
    return new Tokens().fromJsonString(jsonString, options);
  }

  static equals(a: Tokens | PlainMessage<Tokens> | undefined, b: Tokens | PlainMessage<Tokens> | undefined): boolean {
    return proto3.util.equals(Tokens, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Gaussian
 */
export class ImageAdjustment_Gaussian extends Message<ImageAdjustment_Gaussian> {
  /**
   * @generated from field: float sigma = 1;
   */
  sigma = 0;

  /**
   * @generated from field: gooseai.GaussianDirection direction = 2;
   */
  direction = GaussianDirection.DIRECTION_NONE;

  constructor(data?: PartialMessage<ImageAdjustment_Gaussian>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Gaussian";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sigma", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "direction", kind: "enum", T: proto3.getEnumType(GaussianDirection) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Gaussian {
    return new ImageAdjustment_Gaussian().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Gaussian {
    return new ImageAdjustment_Gaussian().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Gaussian {
    return new ImageAdjustment_Gaussian().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Gaussian | PlainMessage<ImageAdjustment_Gaussian> | undefined, b: ImageAdjustment_Gaussian | PlainMessage<ImageAdjustment_Gaussian> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Gaussian, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Invert
 */
export class ImageAdjustment_Invert extends Message<ImageAdjustment_Invert> {
  constructor(data?: PartialMessage<ImageAdjustment_Invert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Invert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Invert {
    return new ImageAdjustment_Invert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Invert {
    return new ImageAdjustment_Invert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Invert {
    return new ImageAdjustment_Invert().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Invert | PlainMessage<ImageAdjustment_Invert> | undefined, b: ImageAdjustment_Invert | PlainMessage<ImageAdjustment_Invert> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Invert, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Levels
 */
export class ImageAdjustment_Levels extends Message<ImageAdjustment_Levels> {
  /**
   * @generated from field: float input_low = 1;
   */
  inputLow = 0;

  /**
   * @generated from field: float input_high = 2;
   */
  inputHigh = 0;

  /**
   * @generated from field: float output_low = 3;
   */
  outputLow = 0;

  /**
   * @generated from field: float output_high = 4;
   */
  outputHigh = 0;

  constructor(data?: PartialMessage<ImageAdjustment_Levels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Levels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "input_low", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "input_high", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "output_low", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "output_high", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Levels {
    return new ImageAdjustment_Levels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Levels {
    return new ImageAdjustment_Levels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Levels {
    return new ImageAdjustment_Levels().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Levels | PlainMessage<ImageAdjustment_Levels> | undefined, b: ImageAdjustment_Levels | PlainMessage<ImageAdjustment_Levels> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Levels, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Channels
 */
export class ImageAdjustment_Channels extends Message<ImageAdjustment_Channels> {
  /**
   * @generated from field: optional gooseai.ChannelSource r = 1;
   */
  r?: ChannelSource;

  /**
   * @generated from field: optional gooseai.ChannelSource g = 2;
   */
  g?: ChannelSource;

  /**
   * @generated from field: optional gooseai.ChannelSource b = 3;
   */
  b?: ChannelSource;

  /**
   * @generated from field: optional gooseai.ChannelSource a = 4;
   */
  a?: ChannelSource;

  constructor(data?: PartialMessage<ImageAdjustment_Channels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Channels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "r", kind: "enum", T: proto3.getEnumType(ChannelSource), opt: true },
    { no: 2, name: "g", kind: "enum", T: proto3.getEnumType(ChannelSource), opt: true },
    { no: 3, name: "b", kind: "enum", T: proto3.getEnumType(ChannelSource), opt: true },
    { no: 4, name: "a", kind: "enum", T: proto3.getEnumType(ChannelSource), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Channels {
    return new ImageAdjustment_Channels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Channels {
    return new ImageAdjustment_Channels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Channels {
    return new ImageAdjustment_Channels().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Channels | PlainMessage<ImageAdjustment_Channels> | undefined, b: ImageAdjustment_Channels | PlainMessage<ImageAdjustment_Channels> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Channels, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Rescale
 */
export class ImageAdjustment_Rescale extends Message<ImageAdjustment_Rescale> {
  /**
   * @generated from field: uint64 height = 1;
   */
  height = protoInt64.zero;

  /**
   * @generated from field: uint64 width = 2;
   */
  width = protoInt64.zero;

  /**
   * @generated from field: gooseai.RescaleMode mode = 3;
   */
  mode = RescaleMode.RESCALE_STRICT;

  /**
   * @generated from field: repeated string algorithm_hint = 4;
   */
  algorithmHint: string[] = [];

  constructor(data?: PartialMessage<ImageAdjustment_Rescale>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Rescale";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "width", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "mode", kind: "enum", T: proto3.getEnumType(RescaleMode) },
    { no: 4, name: "algorithm_hint", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Rescale {
    return new ImageAdjustment_Rescale().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Rescale {
    return new ImageAdjustment_Rescale().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Rescale {
    return new ImageAdjustment_Rescale().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Rescale | PlainMessage<ImageAdjustment_Rescale> | undefined, b: ImageAdjustment_Rescale | PlainMessage<ImageAdjustment_Rescale> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Rescale, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment_Crop
 */
export class ImageAdjustment_Crop extends Message<ImageAdjustment_Crop> {
  /**
   * @generated from field: uint64 top = 1;
   */
  top = protoInt64.zero;

  /**
   * @generated from field: uint64 left = 2;
   */
  left = protoInt64.zero;

  /**
   * @generated from field: uint64 width = 3;
   */
  width = protoInt64.zero;

  /**
   * @generated from field: uint64 height = 4;
   */
  height = protoInt64.zero;

  constructor(data?: PartialMessage<ImageAdjustment_Crop>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment_Crop";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "left", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "width", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment_Crop {
    return new ImageAdjustment_Crop().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment_Crop {
    return new ImageAdjustment_Crop().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment_Crop {
    return new ImageAdjustment_Crop().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment_Crop | PlainMessage<ImageAdjustment_Crop> | undefined, b: ImageAdjustment_Crop | PlainMessage<ImageAdjustment_Crop> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment_Crop, a, b);
  }
}

/**
 * @generated from message gooseai.ImageAdjustment
 */
export class ImageAdjustment extends Message<ImageAdjustment> {
  /**
   * @generated from oneof gooseai.ImageAdjustment.adjustment
   */
  adjustment: {
    /**
     * @generated from field: gooseai.ImageAdjustment_Gaussian blur = 1;
     */
    value: ImageAdjustment_Gaussian;
    case: "blur";
  } | {
    /**
     * @generated from field: gooseai.ImageAdjustment_Invert invert = 2;
     */
    value: ImageAdjustment_Invert;
    case: "invert";
  } | {
    /**
     * @generated from field: gooseai.ImageAdjustment_Levels levels = 3;
     */
    value: ImageAdjustment_Levels;
    case: "levels";
  } | {
    /**
     * @generated from field: gooseai.ImageAdjustment_Channels channels = 4;
     */
    value: ImageAdjustment_Channels;
    case: "channels";
  } | {
    /**
     * @generated from field: gooseai.ImageAdjustment_Rescale rescale = 5;
     */
    value: ImageAdjustment_Rescale;
    case: "rescale";
  } | {
    /**
     * @generated from field: gooseai.ImageAdjustment_Crop crop = 6;
     */
    value: ImageAdjustment_Crop;
    case: "crop";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ImageAdjustment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageAdjustment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blur", kind: "message", T: ImageAdjustment_Gaussian, oneof: "adjustment" },
    { no: 2, name: "invert", kind: "message", T: ImageAdjustment_Invert, oneof: "adjustment" },
    { no: 3, name: "levels", kind: "message", T: ImageAdjustment_Levels, oneof: "adjustment" },
    { no: 4, name: "channels", kind: "message", T: ImageAdjustment_Channels, oneof: "adjustment" },
    { no: 5, name: "rescale", kind: "message", T: ImageAdjustment_Rescale, oneof: "adjustment" },
    { no: 6, name: "crop", kind: "message", T: ImageAdjustment_Crop, oneof: "adjustment" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageAdjustment {
    return new ImageAdjustment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageAdjustment {
    return new ImageAdjustment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageAdjustment {
    return new ImageAdjustment().fromJsonString(jsonString, options);
  }

  static equals(a: ImageAdjustment | PlainMessage<ImageAdjustment> | undefined, b: ImageAdjustment | PlainMessage<ImageAdjustment> | undefined): boolean {
    return proto3.util.equals(ImageAdjustment, a, b);
  }
}

/**
 * A tangible Artifact, such as an image, video, or text that is used for input
 * or output.
 *
 * @generated from message gooseai.Artifact
 */
export class Artifact extends Message<Artifact> {
  /**
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * @generated from field: gooseai.ArtifactType type = 2;
   */
  type = ArtifactType.ARTIFACT_NONE;

  /**
   * MIME type identifier, e.g. "image/png"
   *
   * @generated from field: string mime = 3;
   */
  mime = "";

  /**
   * Magic number, e.g. "PNG"
   *
   * @generated from field: optional string magic = 4;
   */
  magic?: string;

  /**
   * @generated from oneof gooseai.Artifact.data
   */
  data: {
    /**
     * Binary data, e.g. PNG image
     *
     * @generated from field: bytes binary = 5;
     */
    value: Uint8Array;
    case: "binary";
  } | {
    /**
     * Text data, e.g. text prompt
     *
     * @generated from field: string text = 6;
     */
    value: string;
    case: "text";
  } | {
    /**
     * Tokenized text data, e.g. GPT tokens
     *
     * @generated from field: gooseai.Tokens tokens = 7;
     */
    value: Tokens;
    case: "tokens";
  } | {
    /**
     * @generated from field: gooseai.ClassifierParameters classifier = 11;
     */
    value: ClassifierParameters;
    case: "classifier";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Index of this artifact in input/output list
   *
   * @generated from field: uint32 index = 8;
   */
  index = 0;

  /**
   * Reason for finishing, if applicable
   *
   * @generated from field: gooseai.FinishReason finish_reason = 9;
   */
  finishReason = FinishReason.NULL;

  /**
   * Seed used to generate this artifact
   *
   * @generated from field: uint32 seed = 10;
   */
  seed = 0;

  /**
   * Adjustments to this image / mask before generation
   *
   * @generated from field: repeated gooseai.ImageAdjustment adjustments = 500;
   */
  adjustments: ImageAdjustment[] = [];

  /**
   * Adjustments to this image / mask after generation
   *
   * @generated from field: repeated gooseai.ImageAdjustment postAdjustments = 501;
   */
  postAdjustments: ImageAdjustment[] = [];

  constructor(data?: PartialMessage<Artifact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Artifact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ArtifactType) },
    { no: 3, name: "mime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "magic", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "binary", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data" },
    { no: 6, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "data" },
    { no: 7, name: "tokens", kind: "message", T: Tokens, oneof: "data" },
    { no: 11, name: "classifier", kind: "message", T: ClassifierParameters, oneof: "data" },
    { no: 8, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "finish_reason", kind: "enum", T: proto3.getEnumType(FinishReason) },
    { no: 10, name: "seed", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 500, name: "adjustments", kind: "message", T: ImageAdjustment, repeated: true },
    { no: 501, name: "postAdjustments", kind: "message", T: ImageAdjustment, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Artifact {
    return new Artifact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Artifact {
    return new Artifact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Artifact {
    return new Artifact().fromJsonString(jsonString, options);
  }

  static equals(a: Artifact | PlainMessage<Artifact> | undefined, b: Artifact | PlainMessage<Artifact> | undefined): boolean {
    return proto3.util.equals(Artifact, a, b);
  }
}

/**
 * A set of parameters for each individual Prompt.
 *
 * @generated from message gooseai.PromptParameters
 */
export class PromptParameters extends Message<PromptParameters> {
  /**
   * @generated from field: optional bool init = 1;
   */
  init?: boolean;

  /**
   * @generated from field: optional float weight = 2;
   */
  weight?: number;

  constructor(data?: PartialMessage<PromptParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.PromptParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "weight", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromptParameters {
    return new PromptParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromptParameters {
    return new PromptParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromptParameters {
    return new PromptParameters().fromJsonString(jsonString, options);
  }

  static equals(a: PromptParameters | PlainMessage<PromptParameters> | undefined, b: PromptParameters | PlainMessage<PromptParameters> | undefined): boolean {
    return proto3.util.equals(PromptParameters, a, b);
  }
}

/**
 * A Prompt is a special type of Artifact that is used to generate an output.
 * There can be multiple Prompts that affect the same output. Currently, the
 * only Prompts supported are:
 *   - Text (singular)
 *   - Init Image (singular, optional, type ARTIFACT_IMAGE, with init=true)
 *   - Mask (singular, optional, Artifact type ARTIFACT_MASK)
 *
 * @generated from message gooseai.Prompt
 */
export class Prompt extends Message<Prompt> {
  /**
   * @generated from field: optional gooseai.PromptParameters parameters = 1;
   */
  parameters?: PromptParameters;

  /**
   * @generated from oneof gooseai.Prompt.prompt
   */
  prompt: {
    /**
     * @generated from field: string text = 2;
     */
    value: string;
    case: "text";
  } | {
    /**
     * @generated from field: gooseai.Tokens tokens = 3;
     */
    value: Tokens;
    case: "tokens";
  } | {
    /**
     * @generated from field: gooseai.Artifact artifact = 4;
     */
    value: Artifact;
    case: "artifact";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Prompt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Prompt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "message", T: PromptParameters, opt: true },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "prompt" },
    { no: 3, name: "tokens", kind: "message", T: Tokens, oneof: "prompt" },
    { no: 4, name: "artifact", kind: "message", T: Artifact, oneof: "prompt" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Prompt {
    return new Prompt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Prompt {
    return new Prompt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Prompt {
    return new Prompt().fromJsonString(jsonString, options);
  }

  static equals(a: Prompt | PlainMessage<Prompt> | undefined, b: Prompt | PlainMessage<Prompt> | undefined): boolean {
    return proto3.util.equals(Prompt, a, b);
  }
}

/**
 * Parameters that affect the behavior of the sampler, typically used for CFG.
 *
 * @generated from message gooseai.SamplerParameters
 */
export class SamplerParameters extends Message<SamplerParameters> {
  /**
   * @generated from field: optional float eta = 1;
   */
  eta?: number;

  /**
   * @generated from field: optional uint64 sampling_steps = 2;
   */
  samplingSteps?: bigint;

  /**
   * @generated from field: optional uint64 latent_channels = 3;
   */
  latentChannels?: bigint;

  /**
   * @generated from field: optional uint64 downsampling_factor = 4;
   */
  downsamplingFactor?: bigint;

  /**
   * @generated from field: optional float cfg_scale = 5;
   */
  cfgScale?: number;

  constructor(data?: PartialMessage<SamplerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.SamplerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eta", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 2, name: "sampling_steps", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "latent_channels", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "downsampling_factor", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "cfg_scale", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SamplerParameters {
    return new SamplerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SamplerParameters {
    return new SamplerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SamplerParameters {
    return new SamplerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SamplerParameters | PlainMessage<SamplerParameters> | undefined, b: SamplerParameters | PlainMessage<SamplerParameters> | undefined): boolean {
    return proto3.util.equals(SamplerParameters, a, b);
  }
}

/**
 * Unused, but reserved for future use. Adjustments to the latents after
 * initialization.
 *
 * @generated from message gooseai.ConditionerParameters
 */
export class ConditionerParameters extends Message<ConditionerParameters> {
  /**
   * @generated from field: optional string vector_adjust_prior = 1;
   */
  vectorAdjustPrior?: string;

  /**
   * @generated from field: optional gooseai.Model conditioner = 2;
   */
  conditioner?: Model;

  constructor(data?: PartialMessage<ConditionerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ConditionerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector_adjust_prior", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "conditioner", kind: "message", T: Model, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConditionerParameters {
    return new ConditionerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConditionerParameters {
    return new ConditionerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConditionerParameters {
    return new ConditionerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ConditionerParameters | PlainMessage<ConditionerParameters> | undefined, b: ConditionerParameters | PlainMessage<ConditionerParameters> | undefined): boolean {
    return proto3.util.equals(ConditionerParameters, a, b);
  }
}

/**
 * When does this schedule definition apply?
 *
 * @generated from message gooseai.ScheduleParameters
 */
export class ScheduleParameters extends Message<ScheduleParameters> {
  /**
   * 0.0 to 1.0
   *
   * @generated from field: optional float start = 1;
   */
  start?: number;

  /**
   * 0.0 to 1.0
   *
   * @generated from field: optional float end = 2;
   */
  end?: number;

  constructor(data?: PartialMessage<ScheduleParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ScheduleParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 2, name: "end", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleParameters {
    return new ScheduleParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleParameters {
    return new ScheduleParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleParameters {
    return new ScheduleParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleParameters | PlainMessage<ScheduleParameters> | undefined, b: ScheduleParameters | PlainMessage<ScheduleParameters> | undefined): boolean {
    return proto3.util.equals(ScheduleParameters, a, b);
  }
}

/**
 * Parameters that apply to this block of the schedule.
 *
 * @generated from message gooseai.StepParameter
 */
export class StepParameter extends Message<StepParameter> {
  /**
   * @generated from field: float scaled_step = 1;
   */
  scaledStep = 0;

  /**
   * @generated from field: optional gooseai.SamplerParameters sampler = 2;
   */
  sampler?: SamplerParameters;

  /**
   * @generated from field: optional gooseai.ScheduleParameters schedule = 3;
   */
  schedule?: ScheduleParameters;

  /**
   * @generated from field: optional gooseai.GuidanceParameters guidance = 4;
   */
  guidance?: GuidanceParameters;

  constructor(data?: PartialMessage<StepParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.StepParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scaled_step", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "sampler", kind: "message", T: SamplerParameters, opt: true },
    { no: 3, name: "schedule", kind: "message", T: ScheduleParameters, opt: true },
    { no: 4, name: "guidance", kind: "message", T: GuidanceParameters, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StepParameter {
    return new StepParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StepParameter {
    return new StepParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StepParameter {
    return new StepParameter().fromJsonString(jsonString, options);
  }

  static equals(a: StepParameter | PlainMessage<StepParameter> | undefined, b: StepParameter | PlainMessage<StepParameter> | undefined): boolean {
    return proto3.util.equals(StepParameter, a, b);
  }
}

/**
 * @generated from message gooseai.Model
 */
export class Model extends Message<Model> {
  /**
   * @generated from field: gooseai.ModelArchitecture architecture = 1;
   */
  architecture = ModelArchitecture.NONE;

  /**
   * @generated from field: string publisher = 2;
   */
  publisher = "";

  /**
   * @generated from field: string dataset = 3;
   */
  dataset = "";

  /**
   * @generated from field: float version = 4;
   */
  version = 0;

  /**
   * @generated from field: string semantic_version = 5;
   */
  semanticVersion = "";

  /**
   * @generated from field: string alias = 6;
   */
  alias = "";

  constructor(data?: PartialMessage<Model>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Model";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "architecture", kind: "enum", T: proto3.getEnumType(ModelArchitecture) },
    { no: 2, name: "publisher", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dataset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "semantic_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Model {
    return new Model().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJsonString(jsonString, options);
  }

  static equals(a: Model | PlainMessage<Model> | undefined, b: Model | PlainMessage<Model> | undefined): boolean {
    return proto3.util.equals(Model, a, b);
  }
}

/**
 * @generated from message gooseai.CutoutParameters
 */
export class CutoutParameters extends Message<CutoutParameters> {
  /**
   * Nested cutouts, unsupported
   *
   * @generated from field: repeated gooseai.CutoutParameters cutouts = 1;
   */
  cutouts: CutoutParameters[] = [];

  /**
   * 0 to n, usually 8 to 32, 0 inner
   *
   * @generated from field: optional uint32 count = 2;
   */
  count?: number;

  /**
   * 0.0 to 1.0, defaults to 0.2
   *
   * @generated from field: optional float gray = 3;
   */
  gray?: number;

  /**
   * percentage of cutouts to blur
   *
   * @generated from field: optional float blur = 4;
   */
  blur?: number;

  /**
   * defaults to inner: 0.5, outer: 0.0
   *
   * @generated from field: optional float size_power = 5;
   */
  sizePower?: number;

  constructor(data?: PartialMessage<CutoutParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.CutoutParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cutouts", kind: "message", T: CutoutParameters, repeated: true },
    { no: 2, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "gray", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 4, name: "blur", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 5, name: "size_power", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CutoutParameters {
    return new CutoutParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CutoutParameters {
    return new CutoutParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CutoutParameters {
    return new CutoutParameters().fromJsonString(jsonString, options);
  }

  static equals(a: CutoutParameters | PlainMessage<CutoutParameters> | undefined, b: CutoutParameters | PlainMessage<CutoutParameters> | undefined): boolean {
    return proto3.util.equals(CutoutParameters, a, b);
  }
}

/**
 * Parameters that affect the behavior of the guidance, typically used for CLIP.
 * We can specify more than one model, and the guidance will be a weighted sum
 * of the models.
 *
 * @generated from message gooseai.GuidanceInstanceParameters
 */
export class GuidanceInstanceParameters extends Message<GuidanceInstanceParameters> {
  /**
   * models to use for this set
   *
   * @generated from field: repeated gooseai.Model models = 2;
   */
  models: Model[] = [];

  /**
   * 0.0 to 1.0, usually 0.05 to 0.225
   *
   * @generated from field: optional float guidance_strength = 3;
   */
  guidanceStrength?: number;

  /**
   * when to apply guidance
   *
   * @generated from field: repeated gooseai.ScheduleParameters schedule = 4;
   */
  schedule: ScheduleParameters[] = [];

  /**
   * cutout parameters
   *
   * @generated from field: optional gooseai.CutoutParameters cutouts = 5;
   */
  cutouts?: CutoutParameters;

  /**
   * prompt to use for guidance
   *
   * @generated from field: optional gooseai.Prompt prompt = 6;
   */
  prompt?: Prompt;

  constructor(data?: PartialMessage<GuidanceInstanceParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.GuidanceInstanceParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "models", kind: "message", T: Model, repeated: true },
    { no: 3, name: "guidance_strength", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 4, name: "schedule", kind: "message", T: ScheduleParameters, repeated: true },
    { no: 5, name: "cutouts", kind: "message", T: CutoutParameters, opt: true },
    { no: 6, name: "prompt", kind: "message", T: Prompt, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GuidanceInstanceParameters {
    return new GuidanceInstanceParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GuidanceInstanceParameters {
    return new GuidanceInstanceParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GuidanceInstanceParameters {
    return new GuidanceInstanceParameters().fromJsonString(jsonString, options);
  }

  static equals(a: GuidanceInstanceParameters | PlainMessage<GuidanceInstanceParameters> | undefined, b: GuidanceInstanceParameters | PlainMessage<GuidanceInstanceParameters> | undefined): boolean {
    return proto3.util.equals(GuidanceInstanceParameters, a, b);
  }
}

/**
 * Parameters that affect the behavior of the guidance, typically used for CLIP.
 * The omission of this field implies the default guidance of CFG.
 *
 * @generated from message gooseai.GuidanceParameters
 */
export class GuidanceParameters extends Message<GuidanceParameters> {
  /**
   * base preset for guidance
   *
   * @generated from field: gooseai.GuidancePreset guidance_preset = 1;
   */
  guidancePreset = GuidancePreset.NONE;

  /**
   * guidance instances
   *
   * @generated from field: repeated gooseai.GuidanceInstanceParameters instances = 2;
   */
  instances: GuidanceInstanceParameters[] = [];

  constructor(data?: PartialMessage<GuidanceParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.GuidanceParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "guidance_preset", kind: "enum", T: proto3.getEnumType(GuidancePreset) },
    { no: 2, name: "instances", kind: "message", T: GuidanceInstanceParameters, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GuidanceParameters {
    return new GuidanceParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GuidanceParameters {
    return new GuidanceParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GuidanceParameters {
    return new GuidanceParameters().fromJsonString(jsonString, options);
  }

  static equals(a: GuidanceParameters | PlainMessage<GuidanceParameters> | undefined, b: GuidanceParameters | PlainMessage<GuidanceParameters> | undefined): boolean {
    return proto3.util.equals(GuidanceParameters, a, b);
  }
}

/**
 * @generated from message gooseai.TransformType
 */
export class TransformType extends Message<TransformType> {
  /**
   * @generated from oneof gooseai.TransformType.type
   */
  type: {
    /**
     * @generated from field: gooseai.DiffusionSampler diffusion = 1;
     */
    value: DiffusionSampler;
    case: "diffusion";
  } | {
    /**
     * @generated from field: gooseai.Upscaler upscaler = 2;
     */
    value: Upscaler;
    case: "upscaler";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TransformType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.TransformType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "diffusion", kind: "enum", T: proto3.getEnumType(DiffusionSampler), oneof: "type" },
    { no: 2, name: "upscaler", kind: "enum", T: proto3.getEnumType(Upscaler), oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransformType {
    return new TransformType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransformType {
    return new TransformType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransformType {
    return new TransformType().fromJsonString(jsonString, options);
  }

  static equals(a: TransformType | PlainMessage<TransformType> | undefined, b: TransformType | PlainMessage<TransformType> | undefined): boolean {
    return proto3.util.equals(TransformType, a, b);
  }
}

/**
 * @generated from message gooseai.ExtendedParameter
 */
export class ExtendedParameter extends Message<ExtendedParameter> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof gooseai.ExtendedParameter.value
   */
  value: {
    /**
     * @generated from field: float float = 2;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: uint64 int = 3;
     */
    value: bigint;
    case: "int";
  } | {
    /**
     * @generated from field: string str = 4;
     */
    value: string;
    case: "str";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExtendedParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ExtendedParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "value" },
    { no: 3, name: "int", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "value" },
    { no: 4, name: "str", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendedParameter {
    return new ExtendedParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendedParameter {
    return new ExtendedParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendedParameter {
    return new ExtendedParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendedParameter | PlainMessage<ExtendedParameter> | undefined, b: ExtendedParameter | PlainMessage<ExtendedParameter> | undefined): boolean {
    return proto3.util.equals(ExtendedParameter, a, b);
  }
}

/**
 * @generated from message gooseai.ExtendedParameters
 */
export class ExtendedParameters extends Message<ExtendedParameters> {
  /**
   * @generated from field: repeated gooseai.ExtendedParameter parameters = 1;
   */
  parameters: ExtendedParameter[] = [];

  constructor(data?: PartialMessage<ExtendedParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ExtendedParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "message", T: ExtendedParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendedParameters {
    return new ExtendedParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendedParameters {
    return new ExtendedParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendedParameters {
    return new ExtendedParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendedParameters | PlainMessage<ExtendedParameters> | undefined, b: ExtendedParameters | PlainMessage<ExtendedParameters> | undefined): boolean {
    return proto3.util.equals(ExtendedParameters, a, b);
  }
}

/**
 * @generated from message gooseai.ImageParameters
 */
export class ImageParameters extends Message<ImageParameters> {
  /**
   * @generated from field: optional uint64 height = 1;
   */
  height?: bigint;

  /**
   * @generated from field: optional uint64 width = 2;
   */
  width?: bigint;

  /**
   * @generated from field: repeated uint32 seed = 3;
   */
  seed: number[] = [];

  /**
   * @generated from field: optional uint64 samples = 4;
   */
  samples?: bigint;

  /**
   * @generated from field: optional uint64 steps = 5;
   */
  steps?: bigint;

  /**
   * @generated from field: optional gooseai.TransformType transform = 6;
   */
  transform?: TransformType;

  /**
   * @generated from field: repeated gooseai.StepParameter parameters = 7;
   */
  parameters: StepParameter[] = [];

  /**
   * @generated from field: optional gooseai.ExtendedParameters extension = 500;
   */
  extension?: ExtendedParameters;

  constructor(data?: PartialMessage<ImageParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ImageParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "width", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "seed", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 4, name: "samples", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "steps", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 6, name: "transform", kind: "message", T: TransformType, opt: true },
    { no: 7, name: "parameters", kind: "message", T: StepParameter, repeated: true },
    { no: 500, name: "extension", kind: "message", T: ExtendedParameters, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageParameters {
    return new ImageParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageParameters {
    return new ImageParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageParameters {
    return new ImageParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ImageParameters | PlainMessage<ImageParameters> | undefined, b: ImageParameters | PlainMessage<ImageParameters> | undefined): boolean {
    return proto3.util.equals(ImageParameters, a, b);
  }
}

/**
 * @generated from message gooseai.ClassifierConcept
 */
export class ClassifierConcept extends Message<ClassifierConcept> {
  /**
   * @generated from field: string concept = 1;
   */
  concept = "";

  /**
   * @generated from field: optional float threshold = 2;
   */
  threshold?: number;

  constructor(data?: PartialMessage<ClassifierConcept>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ClassifierConcept";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concept", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClassifierConcept {
    return new ClassifierConcept().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClassifierConcept {
    return new ClassifierConcept().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClassifierConcept {
    return new ClassifierConcept().fromJsonString(jsonString, options);
  }

  static equals(a: ClassifierConcept | PlainMessage<ClassifierConcept> | undefined, b: ClassifierConcept | PlainMessage<ClassifierConcept> | undefined): boolean {
    return proto3.util.equals(ClassifierConcept, a, b);
  }
}

/**
 * @generated from message gooseai.ClassifierCategory
 */
export class ClassifierCategory extends Message<ClassifierCategory> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated gooseai.ClassifierConcept concepts = 2;
   */
  concepts: ClassifierConcept[] = [];

  /**
   * @generated from field: optional float adjustment = 3;
   */
  adjustment?: number;

  /**
   * @generated from field: optional gooseai.Action action = 4;
   */
  action?: Action;

  /**
   * @generated from field: optional gooseai.ClassifierMode classifier_mode = 5;
   */
  classifierMode?: ClassifierMode;

  constructor(data?: PartialMessage<ClassifierCategory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ClassifierCategory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "concepts", kind: "message", T: ClassifierConcept, repeated: true },
    { no: 3, name: "adjustment", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 4, name: "action", kind: "enum", T: proto3.getEnumType(Action), opt: true },
    { no: 5, name: "classifier_mode", kind: "enum", T: proto3.getEnumType(ClassifierMode), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClassifierCategory {
    return new ClassifierCategory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClassifierCategory {
    return new ClassifierCategory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClassifierCategory {
    return new ClassifierCategory().fromJsonString(jsonString, options);
  }

  static equals(a: ClassifierCategory | PlainMessage<ClassifierCategory> | undefined, b: ClassifierCategory | PlainMessage<ClassifierCategory> | undefined): boolean {
    return proto3.util.equals(ClassifierCategory, a, b);
  }
}

/**
 * @generated from message gooseai.ClassifierParameters
 */
export class ClassifierParameters extends Message<ClassifierParameters> {
  /**
   * @generated from field: repeated gooseai.ClassifierCategory categories = 1;
   */
  categories: ClassifierCategory[] = [];

  /**
   * @generated from field: repeated gooseai.ClassifierCategory exceeds = 2;
   */
  exceeds: ClassifierCategory[] = [];

  /**
   * @generated from field: optional gooseai.Action realized_action = 3;
   */
  realizedAction?: Action;

  constructor(data?: PartialMessage<ClassifierParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ClassifierParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "categories", kind: "message", T: ClassifierCategory, repeated: true },
    { no: 2, name: "exceeds", kind: "message", T: ClassifierCategory, repeated: true },
    { no: 3, name: "realized_action", kind: "enum", T: proto3.getEnumType(Action), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClassifierParameters {
    return new ClassifierParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClassifierParameters {
    return new ClassifierParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClassifierParameters {
    return new ClassifierParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ClassifierParameters | PlainMessage<ClassifierParameters> | undefined, b: ClassifierParameters | PlainMessage<ClassifierParameters> | undefined): boolean {
    return proto3.util.equals(ClassifierParameters, a, b);
  }
}

/**
 * @generated from message gooseai.AssetParameters
 */
export class AssetParameters extends Message<AssetParameters> {
  /**
   * @generated from field: gooseai.AssetAction action = 1;
   */
  action = AssetAction.ASSET_PUT;

  /**
   * @generated from field: uint64 project = 2;
   */
  project = protoInt64.zero;

  constructor(data?: PartialMessage<AssetParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.AssetParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action", kind: "enum", T: proto3.getEnumType(AssetAction) },
    { no: 2, name: "project", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetParameters {
    return new AssetParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetParameters {
    return new AssetParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetParameters {
    return new AssetParameters().fromJsonString(jsonString, options);
  }

  static equals(a: AssetParameters | PlainMessage<AssetParameters> | undefined, b: AssetParameters | PlainMessage<AssetParameters> | undefined): boolean {
    return proto3.util.equals(AssetParameters, a, b);
  }
}

/**
 * AnswerMeta is a set of metadata about an answer, usually the operating
 * environment.
 *
 * @generated from message gooseai.AnswerMeta
 */
export class AnswerMeta extends Message<AnswerMeta> {
  /**
   * @generated from field: optional string gpu_id = 1;
   */
  gpuId?: string;

  /**
   * @generated from field: optional string cpu_id = 2;
   */
  cpuId?: string;

  /**
   * @generated from field: optional string node_id = 3;
   */
  nodeId?: string;

  /**
   * @generated from field: optional string engine_id = 4;
   */
  engineId?: string;

  constructor(data?: PartialMessage<AnswerMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.AnswerMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gpu_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "cpu_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "engine_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnswerMeta {
    return new AnswerMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnswerMeta {
    return new AnswerMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnswerMeta {
    return new AnswerMeta().fromJsonString(jsonString, options);
  }

  static equals(a: AnswerMeta | PlainMessage<AnswerMeta> | undefined, b: AnswerMeta | PlainMessage<AnswerMeta> | undefined): boolean {
    return proto3.util.equals(AnswerMeta, a, b);
  }
}

/**
 * An Answer is a response to a Request. It is a set of Artifacts, which can be
 * of any type and forwarded to the client or the next stage.
 *
 * @generated from message gooseai.Answer
 */
export class Answer extends Message<Answer> {
  /**
   * @generated from field: string answer_id = 1;
   */
  answerId = "";

  /**
   * @generated from field: string request_id = 2;
   */
  requestId = "";

  /**
   * @generated from field: uint64 received = 3;
   */
  received = protoInt64.zero;

  /**
   * @generated from field: uint64 created = 4;
   */
  created = protoInt64.zero;

  /**
   * @generated from field: optional gooseai.AnswerMeta meta = 6;
   */
  meta?: AnswerMeta;

  /**
   * @generated from field: repeated gooseai.Artifact artifacts = 7;
   */
  artifacts: Artifact[] = [];

  constructor(data?: PartialMessage<Answer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Answer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "answer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "received", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "created", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "meta", kind: "message", T: AnswerMeta, opt: true },
    { no: 7, name: "artifacts", kind: "message", T: Artifact, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Answer {
    return new Answer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Answer {
    return new Answer().fromJsonString(jsonString, options);
  }

  static equals(a: Answer | PlainMessage<Answer> | undefined, b: Answer | PlainMessage<Answer> | undefined): boolean {
    return proto3.util.equals(Answer, a, b);
  }
}

/**
 * A Request is a set of Artifacts, which can be of any type with model or
 * transform parameters. It is sent to the server, which will respond with an
 * Answer.
 *
 * @generated from message gooseai.Request
 */
export class Request extends Message<Request> {
  /**
   * @generated from field: string engine_id = 1;
   */
  engineId = "";

  /**
   * @generated from field: string request_id = 2;
   */
  requestId = "";

  /**
   * @generated from field: gooseai.ArtifactType requested_type = 3;
   */
  requestedType = ArtifactType.ARTIFACT_NONE;

  /**
   * @generated from field: repeated gooseai.Prompt prompt = 4;
   */
  prompt: Prompt[] = [];

  /**
   * @generated from oneof gooseai.Request.params
   */
  params: {
    /**
     * @generated from field: gooseai.ImageParameters image = 5;
     */
    value: ImageParameters;
    case: "image";
  } | {
    /**
     * @generated from field: gooseai.ClassifierParameters classifier = 7;
     */
    value: ClassifierParameters;
    case: "classifier";
  } | {
    /**
     * @generated from field: gooseai.AssetParameters asset = 8;
     */
    value: AssetParameters;
    case: "asset";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional gooseai.ConditionerParameters conditioner = 6;
   */
  conditioner?: ConditionerParameters;

  /**
   * @generated from field: string request_agent = 500;
   */
  requestAgent = "";

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "requested_type", kind: "enum", T: proto3.getEnumType(ArtifactType) },
    { no: 4, name: "prompt", kind: "message", T: Prompt, repeated: true },
    { no: 5, name: "image", kind: "message", T: ImageParameters, oneof: "params" },
    { no: 7, name: "classifier", kind: "message", T: ClassifierParameters, oneof: "params" },
    { no: 8, name: "asset", kind: "message", T: AssetParameters, oneof: "params" },
    { no: 6, name: "conditioner", kind: "message", T: ConditionerParameters, opt: true },
    { no: 500, name: "request_agent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * @generated from message gooseai.OnStatus
 */
export class OnStatus extends Message<OnStatus> {
  /**
   * @generated from field: repeated gooseai.FinishReason reason = 1;
   */
  reason: FinishReason[] = [];

  /**
   * @generated from field: optional string target = 2;
   */
  target?: string;

  /**
   * @generated from field: repeated gooseai.StageAction action = 3;
   */
  action: StageAction[] = [];

  constructor(data?: PartialMessage<OnStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.OnStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "enum", T: proto3.getEnumType(FinishReason), repeated: true },
    { no: 2, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "action", kind: "enum", T: proto3.getEnumType(StageAction), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OnStatus {
    return new OnStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OnStatus {
    return new OnStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OnStatus {
    return new OnStatus().fromJsonString(jsonString, options);
  }

  static equals(a: OnStatus | PlainMessage<OnStatus> | undefined, b: OnStatus | PlainMessage<OnStatus> | undefined): boolean {
    return proto3.util.equals(OnStatus, a, b);
  }
}

/**
 * @generated from message gooseai.Stage
 */
export class Stage extends Message<Stage> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: gooseai.Request request = 2;
   */
  request?: Request;

  /**
   * @generated from field: repeated gooseai.OnStatus on_status = 3;
   */
  onStatus: OnStatus[] = [];

  constructor(data?: PartialMessage<Stage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.Stage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "request", kind: "message", T: Request },
    { no: 3, name: "on_status", kind: "message", T: OnStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Stage {
    return new Stage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Stage {
    return new Stage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Stage {
    return new Stage().fromJsonString(jsonString, options);
  }

  static equals(a: Stage | PlainMessage<Stage> | undefined, b: Stage | PlainMessage<Stage> | undefined): boolean {
    return proto3.util.equals(Stage, a, b);
  }
}

/**
 * @generated from message gooseai.ChainRequest
 */
export class ChainRequest extends Message<ChainRequest> {
  /**
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * @generated from field: repeated gooseai.Stage stage = 2;
   */
  stage: Stage[] = [];

  constructor(data?: PartialMessage<ChainRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "gooseai.ChainRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stage", kind: "message", T: Stage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainRequest {
    return new ChainRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainRequest {
    return new ChainRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainRequest {
    return new ChainRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ChainRequest | PlainMessage<ChainRequest> | undefined, b: ChainRequest | PlainMessage<ChainRequest> | undefined): boolean {
    return proto3.util.equals(ChainRequest, a, b);
  }
}

